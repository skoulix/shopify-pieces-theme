
{%- comment -%}
  Predictive Search Component
  Real-time search suggestions as user types
{%- endcomment -%}

<predictive-search
  class="predictive-search relative z-999"
  data-loading-text="{{ 'search.loading' | t }}"
  data-no-results-text="{{ 'search.no_results' | t }}"
  data-error-text="{{ 'search.error' | t | default: 'Search temporarily unavailable' }}"
  data-products-heading="{{ 'search.filter_products' | t }}"
  data-articles-heading="{{ 'search.filter_articles' | t }}"
  data-pages-heading="{{ 'search.filter_pages' | t }}"
  data-view-all-text="{{ 'search.view_all' | t }}"
  data-trending-heading="{{ 'search.trending' | t | default: 'Trending' }}"
>
  {%- liquid
    # Generate unique ID for this instance to support multiple instances on a page
    assign unique_id = 'now' | date: '%N' | slice: -6, 6
  -%}
  <form action="{{ routes.search_url }}" method="get" role="search" class="predictive-search__form">
    <div class="predictive-search__input-wrapper relative">
      <input type="hidden" name="type" value="product,article,page">
      <input type="hidden" name="options[prefix]" value="last">
      <label for="predictive-search-input-{{ unique_id }}" class="sr-only">{{ 'search.placeholder' | t }}</label>
      <input
        type="search"
        id="predictive-search-input-{{ unique_id }}"
        name="q"
        value="{{ search.terms | escape }}"
        class="predictive-search__input w-full py-3 px-4 pr-12 bg-transparent border border-(--color-border) rounded-(--input-radius) text-(--color-text) placeholder:text-(--color-text-secondary) focus:outline-none focus:border-(--color-primary) transition-colors"
        placeholder="{{ 'search.placeholder' | t }}"
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        aria-controls="predictive-search-results-{{ unique_id }}"
        aria-autocomplete="list"
        data-predictive-search-input
      >
      <button
        type="submit"
        class="predictive-search__submit absolute right-0 top-0 h-full px-4 text-(--color-text-secondary) hover:text-(--color-text) transition-colors"
        aria-label="{{ 'search.submit' | t }}"
      >
        <i class="ph ph-magnifying-glass text-xl"></i>
      </button>
      <button
        type="button"
        class="predictive-search__clear absolute right-14 top-1/2 -translate-y-1/2 p-2 text-(--color-text-secondary) hover:text-(--color-text) transition-colors hidden"
        aria-label="{{ 'search.clear' | t }}"
        data-predictive-search-clear
      >
        <i class="ph ph-x text-lg"></i>
      </button>
    </div>

    <div
      id="predictive-search-results-{{ unique_id }}"
      class="predictive-search__results absolute top-full left-0 right-0 mt-2 bg-(--color-background) border border-(--color-border) rounded-(--card-radius) shadow-xl overflow-hidden z-999 hidden"
      role="listbox"
      data-predictive-search-results
      data-lenis-prevent
    >
      <div class="predictive-search__loading bg-(--color-background) hidden" data-predictive-search-loading>
        <div class="px-4 py-2 bg-(--color-background-secondary)">
          <div class="predictive-search__skeleton h-3 w-20"></div>
        </div>
        <div class="predictive-search__products-grid p-3">
          {%- for i in (1..4) -%}
          <div class="predictive-search__skeleton-card">
            <div class="predictive-search__skeleton predictive-search__skeleton-image"></div>
            <div class="predictive-search__skeleton-info">
              <div class="predictive-search__skeleton predictive-search__skeleton-title"></div>
              <div class="predictive-search__skeleton predictive-search__skeleton-price"></div>
            </div>
          </div>
          {%- endfor -%}
        </div>
      </div>

      <div class="predictive-search__content bg-(--color-background)" data-predictive-search-content>
        {%- comment -%} Results injected here via JS {%- endcomment -%}
      </div>
    </div>
  </form>
</predictive-search>

<script>
if (!customElements.get('predictive-search')) {
class PredictiveSearch extends HTMLElement {
  constructor() {
    super();
    this.cachedResults = {};
    this.cachedRecommendations = null;
    this.debounceTimer = null;
  }

  connectedCallback() {
    // Query DOM elements after the element is connected
    this.input = this.querySelector('[data-predictive-search-input]');
    this.results = this.querySelector('[data-predictive-search-results]');
    this.content = this.querySelector('[data-predictive-search-content]');
    this.loading = this.querySelector('[data-predictive-search-loading]');
    this.clearBtn = this.querySelector('[data-predictive-search-clear]');

    if (!this.input || !this.results) return;

    this.setupEventListeners();

    // Show clear button if input already has value (e.g., on search results page)
    if (this.input.value.trim().length > 0) {
      this.clearBtn?.classList.remove('hidden');
    }
  }

  setupEventListeners() {
    // Store bound handlers for cleanup
    this.boundOnChange = this.debounce(() => this.onChange(), 300);
    this.boundOnFocus = () => this.onFocus();
    this.boundOnClear = () => this.clear();
    this.boundOnDocumentClick = (e) => {
      if (!this.contains(e.target)) this.close();
    };
    this.boundOnDocumentKeydown = (e) => {
      if (e.key === 'Escape' && this.results && !this.results.classList.contains('hidden')) {
        this.close();
        this.input?.blur();
      }
    };
    this.boundOnResultsKeydown = (e) => this.onKeydown(e);

    this.input.addEventListener('input', this.boundOnChange);
    this.input.addEventListener('focus', this.boundOnFocus);
    this.clearBtn?.addEventListener('click', this.boundOnClear);

    // Close when clicking outside this specific instance
    document.addEventListener('click', this.boundOnDocumentClick);

    // Close on escape only if this instance's results are visible
    document.addEventListener('keydown', this.boundOnDocumentKeydown);

    this.results.addEventListener('keydown', this.boundOnResultsKeydown);
  }

  disconnectedCallback() {
    // Clean up event listeners to prevent memory leaks
    if (this.input) {
      this.input.removeEventListener('input', this.boundOnChange);
      this.input.removeEventListener('focus', this.boundOnFocus);
    }
    this.clearBtn?.removeEventListener('click', this.boundOnClear);
    document.removeEventListener('click', this.boundOnDocumentClick);
    document.removeEventListener('keydown', this.boundOnDocumentKeydown);
    if (this.results) {
      this.results.removeEventListener('keydown', this.boundOnResultsKeydown);
    }
    clearTimeout(this.debounceTimer);
  }

  debounce(fn, wait) {
    return (...args) => {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  onChange() {
    const searchTerm = this.input.value.trim();

    if (searchTerm.length === 0) {
      this.clearBtn?.classList.add('hidden');
      // Show recommendations when input is cleared
      this.getRecommendations();
      return;
    }

    this.clearBtn?.classList.remove('hidden');

    if (searchTerm.length < 2) return;

    this.getSearchResults(searchTerm);
  }

  onFocus() {
    const searchTerm = this.input.value.trim();
    if (searchTerm.length >= 2) {
      this.getSearchResults(searchTerm);
    } else if (searchTerm.length === 0) {
      // Show recommendations when focusing empty input
      this.getRecommendations();
    }
  }

  async getSearchResults(searchTerm) {
    if (this.cachedResults[searchTerm]) {
      this.renderResults(this.cachedResults[searchTerm]);
      return;
    }

    this.showLoading();

    // Abort any previous pending search request
    if (this.searchController) this.searchController.abort();
    this.searchController = new AbortController();
    const timeoutId = setTimeout(() => this.searchController.abort(), 8000);

    try {
      const response = await fetch(
        `${window.Shopify.routes.root}search/suggest.json?q=${encodeURIComponent(searchTerm)}&resources[type]=product,article,page&resources[limit]=4&resources[options][unavailable_products]=last`,
        { signal: this.searchController.signal }
      );

      clearTimeout(timeoutId);

      if (!response.ok) throw new Error('Search failed');

      const data = await response.json();
      this.cachedResults[searchTerm] = data;
      this.renderResults(data);
    } catch (error) {
      clearTimeout(timeoutId);
      // Ignore abort errors (user typed new query)
      if (error.name === 'AbortError') return;
      if (window.Shopify?.designMode) console.error('Predictive search error:', error);
      this.showError();
    }
  }

  showError() {
    this.content.innerHTML = `
      <div class="p-6 text-center text-(--color-text-secondary)">
        <p class="text-sm">${this.dataset.errorText}</p>
      </div>
    `;
    this.loading.classList.add('hidden');
    this.content.classList.remove('hidden');
    this.results.classList.remove('hidden');
  }

  async getRecommendations() {
    // Use cached recommendations if available
    if (this.cachedRecommendations) {
      this.renderRecommendations(this.cachedRecommendations);
      return;
    }

    this.showLoading();

    // Abort any previous pending recommendation request
    if (this.recsController) this.recsController.abort();
    this.recsController = new AbortController();
    const timeoutId = setTimeout(() => this.recsController.abort(), 8000);

    try {
      // Fetch trending/popular products using product recommendations API
      const response = await fetch(
        `${window.Shopify.routes.root}recommendations/products.json?limit=6&intent=related`,
        { signal: this.recsController.signal }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.products && data.products.length > 0) {
          clearTimeout(timeoutId);
          this.cachedRecommendations = data.products;
          this.renderRecommendations(data.products);
          return;
        }
      }

      // Fallback: fetch from a collection or search for popular terms
      const fallbackResponse = await fetch(
        `${window.Shopify.routes.root}search/suggest.json?q=*&resources[type]=product&resources[limit]=6&resources[options][unavailable_products]=last`,
        { signal: this.recsController.signal }
      );

      clearTimeout(timeoutId);

      if (fallbackResponse.ok) {
        const fallbackData = await fallbackResponse.json();
        const products = fallbackData.resources?.results?.products || [];
        this.cachedRecommendations = products;
        this.renderRecommendations(products);
      } else {
        this.close();
      }
    } catch (error) {
      clearTimeout(timeoutId);
      // Ignore abort errors
      if (error.name === 'AbortError') return;
      if (window.Shopify?.designMode) console.error('Recommendations error:', error);
      // For recommendations, just close silently - not critical
      this.close();
    }
  }

  renderRecommendations(products) {
    if (!products || products.length === 0) {
      this.close();
      return;
    }

    const html = `
      <div class="predictive-search__section">
        <h3 class="px-4 py-2 text-sm font-semibold uppercase tracking-wider text-(--color-text-secondary) bg-(--color-background-secondary)">
          ${this.dataset.trendingHeading}
        </h3>
        <div class="predictive-search__products-grid">
          ${products.map(product => {
            // Handle both API response formats
            const url = product.url || `/products/${product.handle}`;
            const image = product.image || (product.featured_image ? product.featured_image : (product.images && product.images[0] ? product.images[0] : null));
            const imageUrl = typeof image === 'string' ? image : (image?.src || '');
            const price = product.price || (product.price_min ? window.Shopify.formatMoney(product.price_min) : '');

            return `
              <a href="${url}" class="predictive-search__product-card" role="option">
                <div class="predictive-search__product-image">
                  ${imageUrl ? `<img src="${imageUrl}" alt="${product.title}" loading="lazy" decoding="async">` : '<i class="ph ph-image text-xl text-(--color-text-secondary) opacity-40"></i>'}
                </div>
                <div class="predictive-search__product-info">
                  <p class="predictive-search__product-title">${product.title}</p>
                  <p class="predictive-search__product-price">${price}</p>
                </div>
              </a>
            `;
          }).join('')}
        </div>
      </div>
    `;

    this.content.innerHTML = html;
    this.loading.classList.add('hidden');
    this.content.classList.remove('hidden');
    this.results.classList.remove('hidden');
  }

  showLoading() {
    this.results.classList.remove('hidden');
    this.loading.classList.remove('hidden');
    this.content.classList.add('hidden');
  }

  renderResults(data) {
    const resources = data.resources?.results || {};
    const products = resources.products || [];
    const articles = resources.articles || [];
    const pages = resources.pages || [];

    if (products.length === 0 && articles.length === 0 && pages.length === 0) {
      if (!this.input.value.trim()) {
        this.close();
        return;
      }
      this.content.innerHTML = `
        <div class="p-6 text-center text-(--color-text-secondary)">
          <p class="text-sm">${this.dataset.noResultsText}</p>
        </div>
      `;
    } else {
      let html = '';

      if (products.length > 0) {
        html += `
          <div class="predictive-search__section">
            <h3 class="px-4 py-2 text-sm font-semibold uppercase tracking-wider text-(--color-text-secondary) bg-(--color-background-secondary)">
              ${this.dataset.productsHeading}
            </h3>
            <div class="predictive-search__products-grid">
              ${products.map(product => `
                <a href="${product.url}" class="predictive-search__product-card" role="option">
                  <div class="predictive-search__product-image">
                    ${product.image ? `
                      <img src="${product.image}" alt="${product.title}" loading="lazy" decoding="async">
                    ` : '<i class="ph ph-image text-xl text-(--color-text-secondary) opacity-40"></i>'}
                  </div>
                  <div class="predictive-search__product-info">
                    <p class="predictive-search__product-title">${product.title}</p>
                    <p class="predictive-search__product-price">${product.price}</p>
                  </div>
                </a>
              `).join('')}
            </div>
          </div>
        `;
      }

      if (articles.length > 0) {
        html += `
          <div class="predictive-search__section">
            <h3 class="px-4 py-2 text-sm font-semibold uppercase tracking-wider text-(--color-text-secondary) bg-(--color-background-secondary)">
              ${this.dataset.articlesHeading}
            </h3>
            <ul class="divide-y divide-(--color-border)">
              ${articles.map(article => `
                <li>
                  <a href="${article.url}" class="block p-4 hover:bg-(--color-background-secondary) transition-colors" role="option">
                    <p class="text-sm font-medium text-(--color-text)">${article.title}</p>
                  </a>
                </li>
              `).join('')}
            </ul>
          </div>
        `;
      }

      if (pages.length > 0) {
        html += `
          <div class="predictive-search__section">
            <h3 class="px-4 py-2 text-sm font-semibold uppercase tracking-wider text-(--color-text-secondary) bg-(--color-background-secondary)">
              ${this.dataset.pagesHeading}
            </h3>
            <ul class="divide-y divide-(--color-border)">
              ${pages.map(page => `
                <li>
                  <a href="${page.url}" class="block p-4 hover:bg-(--color-background-secondary) transition-colors" role="option">
                    <p class="text-sm font-medium text-(--color-text)">${page.title}</p>
                  </a>
                </li>
              `).join('')}
            </ul>
          </div>
        `;
      }

      // Add "View All Results" link
      const searchUrl = this.closest('form')?.action || '/search';
      const searchQuery = encodeURIComponent(this.input.value);
      html += `
        <div class="predictive-search__view-all p-4 border-t border-(--color-border) text-center">
          <a href="${searchUrl}?q=${searchQuery}&type=product,article,page" class="btn btn--secondary btn--sm">
            {%- if settings.button_hover_slide_text -%}<span data-hover="${this.dataset.viewAllText} &quot;${this.input.value}&quot;"><span>${this.dataset.viewAllText} "${this.input.value}"</span></span>{%- else -%}<span>${this.dataset.viewAllText} "${this.input.value}"</span>{%- endif -%}
          </a>
        </div>
      `;

      this.content.innerHTML = html;
    }

    this.loading.classList.add('hidden');
    this.content.classList.remove('hidden');
    this.results.classList.remove('hidden');
  }

  onKeydown(e) {
    const focusableElements = this.results.querySelectorAll('a[role="option"], button');
    if (!focusableElements.length) return;

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (document.activeElement === this.input) {
        this.setActiveOption(firstElement, focusableElements);
      } else {
        const currentIndex = Array.from(focusableElements).indexOf(document.activeElement);
        const nextElement = focusableElements[currentIndex + 1];
        if (nextElement) {
          this.setActiveOption(nextElement, focusableElements);
        }
      }
    }

    if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (document.activeElement === firstElement) {
        this.clearActiveOptions(focusableElements);
        this.input.focus();
      } else {
        const currentIndex = Array.from(focusableElements).indexOf(document.activeElement);
        const prevElement = focusableElements[currentIndex - 1];
        if (prevElement) {
          this.setActiveOption(prevElement, focusableElements);
        }
      }
    }
  }

  setActiveOption(element, allElements) {
    // Clear previous selection
    this.clearActiveOptions(allElements);
    // Set new selection
    element.setAttribute('aria-selected', 'true');
    element.classList.add('is-keyboard-focused');
    element.focus();
  }

  clearActiveOptions(elements) {
    elements.forEach(el => {
      el.removeAttribute('aria-selected');
      el.classList.remove('is-keyboard-focused');
    });
  }

  clear() {
    this.input.value = '';
    this.input.focus();
    this.close();
    this.clearBtn?.classList.add('hidden');
  }

  close() {
    this.results.classList.add('hidden');
  }
}

customElements.define('predictive-search', PredictiveSearch);
}
</script>
